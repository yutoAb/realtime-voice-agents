<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Realtime Voice Agent Demo</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 860px;
            margin: 32px auto;
        }

        button {
            padding: 8px 14px;
            margin-right: 10px;
        }

        pre {
            background: #f5f5f5;
            padding: 12px;
        }

        input {
            padding: 6px 8px;
            width: 260px;
        }

        label {
            display: inline-block;
            width: 100px;
        }
    </style>
</head>

<body>
    <h1>Realtime Voice Agent Demo</h1>
    <p>
        <button id="connect">üéô Connect & Talk</button>
        <button id="disconnect" disabled>‚ùå Disconnect</button>
    </p>
    <div>
        <label>ÂêçÂâç</label>
        <input id="userName" placeholder="„ÅäÂêçÂâç (‰ªªÊÑè)" />
    </div>
    <audio id="remoteAudio" autoplay></audio>
    <pre id="log"></pre>

    <script>
        const logEl = document.getElementById('log');
        function log(...args) {
            logEl.textContent += args.join(' ') + "\n";
        }

        const btnConnect = document.getElementById('connect');
        const btnDisconnect = document.getElementById('disconnect');
        const remoteAudio = document.getElementById('remoteAudio');
        const userName = document.getElementById('userName');

        let pc, dc, localStream;

        async function getClientSecret() {
            const r = await fetch('http://localhost:8000/realtime/token', {
                method: 'POST',
                headers: { 'content-type': 'application/json' },
                body: JSON.stringify({ user_id: 'demo-user' })
            });
            if (!r.ok) {
                throw new Error(await r.text());
            }
            const data = await r.json();
            return data.client_secret?.value;
        }

        async function connect() {
            btnConnect.disabled = true;

            const token = await getClientSecret();
            if (!token) throw new Error("No ephemeral token");

            pc = new RTCPeerConnection();
            dc = pc.createDataChannel('oai-events');

            dc.onmessage = (ev) => {
                try {
                    const msg = JSON.parse(ev.data);
                    if (msg.type === 'response.function_call') handleFunctionCall(msg);
                    if (msg.type === 'session.created') log('‚úÖ Session created');
                } catch (e) { }
            };

            pc.ontrack = (e) => {
                remoteAudio.srcObject = e.streams[0];
            };

            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            for (const track of localStream.getTracks()) {
                pc.addTrack(track, localStream);
            }

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            const model = 'gpt-4o-realtime-preview';
            const sdpRes = await fetch(`https://api.openai.com/v1/realtime?model=${model}`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/sdp'
                },
                body: offer.sdp,
            });
            const answerSdp = await sdpRes.text();
            await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });

            btnDisconnect.disabled = false;
            log('üé§ Connected to model.');
        }

        async function handleFunctionCall(msg) {
            const { call_id, name, arguments: args } = msg;

            try {
                let toolOutput;

                if (name === 'list_hospitals') {
                    const url = new URL('http://localhost:8000/hospitals');
                    url.searchParams.set('lat', String(args.lat));
                    url.searchParams.set('lon', String(args.lon));
                    if (args.distance_km) {
                        url.searchParams.set('distance_km', String(args.distance_km));
                    }
                    toolOutput = await fetch(url).then(r => r.json());

                } else if (name === 'create_visit') {
                    const nameVal = userName.value || 'ÂåøÂêç';
                    toolOutput = await fetch('http://localhost:8000/visit', {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify({
                            hospital_id: args.hospital_id,
                            slot: args.slot,
                            name: nameVal
                        })
                    }).then(r => r.json());

                } else if (name === 'diagnose') {
                    toolOutput = await fetch('http://localhost:8000/diagnose', {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify({ symptoms: args.symptoms })
                    }).then(r => r.json());
                }

                dc.send(JSON.stringify({
                    type: 'response.function_call_output',
                    call_id,
                    output: toolOutput
                }));
            } catch (err) {
                dc.send(JSON.stringify({
                    type: 'response.function_call_output',
                    call_id,
                    error: String(err)
                }));
            }
        }

        function disconnect() {
            btnDisconnect.disabled = true;
            btnConnect.disabled = false;

            if (dc) {
                dc.close(); dc = null;
            }
            if (pc) {
                pc.close(); pc = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
            }
            log('‚ùå Disconnected.');
        }

        btnConnect.onclick = () => connect().catch(e => {
            log('ERR', e.message);
            btnConnect.disabled = false;
        });

        btnDisconnect.onclick = () => disconnect();
    </script>
</body>

</html>